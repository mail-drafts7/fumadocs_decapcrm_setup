---
title: Testing
description: Comprehensive testing guide for Knowledge Pack - unit tests, integration tests, and end-to-end testing strategies
---

# Testing

Testing is a crucial part of maintaining high-quality documentation and ensuring your Knowledge Pack setup works reliably. This comprehensive guide covers all aspects of testing, from basic unit tests to advanced end-to-end testing scenarios.

## Testing Philosophy

### Why Test Your Documentation?

Documentation testing ensures that:

- **Content Accuracy**: All code examples and tutorials actually work
- **Link Validity**: Internal and external links function correctly
- **Performance**: Pages load quickly and efficiently
- **Accessibility**: Content is accessible to all users
- **Cross-platform Compatibility**: Documentation works across different devices and browsers

### Testing Pyramid

Knowledge Pack follows the testing pyramid approach:

```
    /\     E2E Tests (Few)
   /  \    - User workflows
  /____\   - Critical paths
 /      \  
/________\  Integration Tests (Some)
           - Component interactions
           - API integrations

/__________\ Unit Tests (Many)
             - Individual functions
             - Component logic
             - Utilities
```

## Testing Stack

### Core Testing Tools

- **Jest** - JavaScript testing framework
- **React Testing Library** - Component testing utilities
- **Playwright** - End-to-end testing
- **MSW (Mock Service Worker)** - API mocking
- **Testing Library Jest DOM** - Custom matchers

### Additional Tools

- **Storybook** - Component documentation and testing
- **Chromatic** - Visual regression testing
- **Axe** - Accessibility testing
- **Lighthouse CI** - Performance testing

## Unit Testing

### Setting Up Jest

Install the required testing dependencies:

```bash
npm install --save-dev jest @testing-library/react @testing-library/jest-dom @testing-library/user-event jest-environment-jsdom
```

Create `jest.config.js`:

```javascript
/** @type {import('jest').Config} */
const config = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  collectCoverageFrom: [
    'components/**/*.{js,jsx,ts,tsx}',
    'lib/**/*.{js,jsx,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};

module.exports = config;
```

Create `jest.setup.js`:

```javascript
import '@testing-library/jest-dom';

// Mock Next.js router
jest.mock('next/router', () => ({
  useRouter() {
    return {
      route: '/',
      pathname: '/',
      query: {},
      asPath: '/',
      push: jest.fn(),
      replace: jest.fn(),
    };
  },
}));

// Mock next/image
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props) => <img {...props} />,
}));
```

### Testing Components

#### Basic Component Test

```javascript
// __tests__/components/SearchBox.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import SearchBox from '@/components/SearchBox';

describe('SearchBox', () => {
  it('renders search input', () => {
    render(<SearchBox />);
    expect(screen.getByPlaceholderText(/search/i)).toBeInTheDocument();
  });

  it('calls onSearch when typing', async () => {
    const user = userEvent.setup();
    const mockOnSearch = jest.fn();
    
    render(<SearchBox onSearch={mockOnSearch} />);
    
    const input = screen.getByPlaceholderText(/search/i);
    await user.type(input, 'test query');
    
    expect(mockOnSearch).toHaveBeenCalledWith('test query');
  });

  it('clears input when clear button is clicked', async () => {
    const user = userEvent.setup();
    render(<SearchBox />);
    
    const input = screen.getByPlaceholderText(/search/i);
    await user.type(input, 'test');
    
    const clearButton = screen.getByRole('button', { name: /clear/i });
    await user.click(clearButton);
    
    expect(input).toHaveValue('');
  });
});
```

#### Testing Hooks

```javascript
// __tests__/hooks/useSearch.test.js
import { renderHook, act } from '@testing-library/react';
import { useSearch } from '@/hooks/useSearch';

describe('useSearch', () => {
  it('initializes with empty query', () => {
    const { result } = renderHook(() => useSearch());
    expect(result.current.query).toBe('');
    expect(result.current.results).toEqual([]);
  });

  it('updates query and results', async () => {
    const { result } = renderHook(() => useSearch());
    
    await act(async () => {
      result.current.search('test');
    });
    
    expect(result.current.query).toBe('test');
    expect(result.current.results).toHaveLength(2);
  });
});
```

### Testing Utilities

```javascript
// __tests__/lib/markdown.test.js
import { parseMarkdown, generateTOC } from '@/lib/markdown';

describe('markdown utilities', () => {
  describe('parseMarkdown', () => {
    it('parses basic markdown', () => {
      const markdown = '# Title\n\nParagraph with **bold** text.';
      const result = parseMarkdown(markdown);
      
      expect(result).toContain('<h1>Title</h1>');
      expect(result).toContain('<strong>bold</strong>');
    });

    it('handles code blocks', () => {
      const markdown = '```javascript\nconst x = 1;\n```';
      const result = parseMarkdown(markdown);
      
      expect(result).toContain('<pre>');
      expect(result).toContain('const x = 1;');
    });
  });

  describe('generateTOC', () => {
    it('generates table of contents', () => {
      const content = '# Title\n## Section 1\n### Subsection\n## Section 2';
      const toc = generateTOC(content);
      
      expect(toc).toHaveLength(3);
      expect(toc[0]).toEqual({
        level: 2,
        title: 'Section 1',
        slug: 'section-1'
      });
    });
  });
});
```

## Integration Testing

### Testing Page Components

```javascript
// __tests__/pages/docs.test.jsx
import { render, screen } from '@testing-library/react';
import DocsPage from '@/app/docs/[...slug]/page';
import { docs } from '@/source.config';

// Mock the docs source
jest.mock('@/source.config', () => ({
  docs: [
    {
      slugs: ['getting-started'],
      data: {
        title: 'Getting Started',
        description: 'Test description',
        body: () => <div>Test content</div>,
        toc: [{ title: 'Section 1', url: '#section-1' }],
      },
    },
  ],
}));

describe('DocsPage', () => {
  it('renders page content', () => {
    render(<DocsPage params={{ slug: ['getting-started'] }} />);
    
    expect(screen.getByText('Getting Started')).toBeInTheDocument();
    expect(screen.getByText('Test content')).toBeInTheDocument();
  });

  it('renders table of contents', () => {
    render(<DocsPage params={{ slug: ['getting-started'] }} />);
    
    expect(screen.getByText('Section 1')).toBeInTheDocument();
  });
});
```

### Testing Navigation

```javascript
// __tests__/components/Navigation.test.jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Navigation from '@/components/Navigation';

const mockTree = {
  name: 'Docs',
  children: [
    {
      type: 'page',
      name: 'Getting Started',
      url: '/getting-started',
    },
    {
      type: 'page',
      name: 'Testing',
      url: '/testing',
    },
  ],
};

describe('Navigation', () => {
  it('renders navigation items', () => {
    render(<Navigation tree={mockTree} />);
    
    expect(screen.getByText('Getting Started')).toBeInTheDocument();
    expect(screen.getByText('Testing')).toBeInTheDocument();
  });

  it('highlights active page', () => {
    render(<Navigation tree={mockTree} currentPath="/getting-started" />);
    
    const activeLink = screen.getByText('Getting Started');
    expect(activeLink.closest('a')).toHaveClass('active');
  });
});
```

### API Integration Testing

```javascript
// __tests__/api/search.test.js
import { GET } from '@/app/api/search/route';
import { NextRequest } from 'next/server';

describe('/api/search', () => {
  it('returns search results', async () => {
    const url = 'http://localhost:3000/api/search?q=testing';
    const request = new NextRequest(url);
    
    const response = await GET(request);
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.results).toBeInstanceOf(Array);
    expect(data.query).toBe('testing');
  });

  it('handles empty query', async () => {
    const url = 'http://localhost:3000/api/search?q=';
    const request = new NextRequest(url);
    
    const response = await GET(request);
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.results).toEqual([]);
  });
});
```

## End-to-End Testing

### Playwright Setup

Install Playwright:

```bash
npm install --save-dev @playwright/test
npx playwright install
```

Create `playwright.config.ts`:

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 30000,
  expect: { timeout: 5000 },
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});
```

### E2E Test Examples

#### Navigation Test

```typescript
// e2e/navigation.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Navigation', () => {
  test('navigates between pages', async ({ page }) => {
    await page.goto('/');
    
    // Click getting started link
    await page.getByText('Getting Started').click();
    await expect(page).toHaveURL('/getting-started');
    await expect(page.getByRole('heading', { name: 'Getting Started' })).toBeVisible();
    
    // Navigate to testing page
    await page.getByText('Testing').click();
    await expect(page).toHaveURL('/testing');
    await expect(page.getByRole('heading', { name: 'Testing' })).toBeVisible();
  });

  test('mobile navigation works', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    
    // Open mobile menu
    await page.getByRole('button', { name: /menu/i }).click();
    await expect(page.getByText('Getting Started')).toBeVisible();
  });
});
```

#### Search Functionality

```typescript
// e2e/search.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Search', () => {
  test('searches documentation', async ({ page }) => {
    await page.goto('/');
    
    // Open search
    await page.keyboard.press('Control+k');
    await expect(page.getByPlaceholder(/search/i)).toBeVisible();
    
    // Type search query
    await page.fill('[placeholder*="search"]', 'testing');
    
    // Verify results appear
    await expect(page.getByText('Testing')).toBeVisible();
    await expect(page.getByText('Unit Testing')).toBeVisible();
    
    // Click on result
    await page.getByText('Testing').first().click();
    await expect(page).toHaveURL('/testing');
  });

  test('handles no results', async ({ page }) => {
    await page.goto('/');
    await page.keyboard.press('Control+k');
    
    await page.fill('[placeholder*="search"]', 'nonexistentquery123');
    await expect(page.getByText(/no results found/i)).toBeVisible();
  });
});
```

### Visual Testing

```typescript
// e2e/visual.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Visual Tests', () => {
  test('homepage matches screenshot', async ({ page }) => {
    await page.goto('/');
    await expect(page).toHaveScreenshot('homepage.png');
  });

  test('docs page matches screenshot', async ({ page }) => {
    await page.goto('/getting-started');
    await expect(page).toHaveScreenshot('getting-started.png');
  });

  test('dark mode works', async ({ page }) => {
    await page.goto('/');
    
    // Toggle dark mode
    await page.getByRole('button', { name: /theme/i }).click();
    await page.getByText('Dark').click();
    
    // Verify dark mode applied
    await expect(page.locator('html')).toHaveClass(/dark/);
    await expect(page).toHaveScreenshot('homepage-dark.png');
  });
});
```

## Accessibility Testing

### Automated Accessibility Tests

```javascript
// __tests__/accessibility.test.js
import { render } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import HomePage from '@/app/page';

expect.extend(toHaveNoViolations);

describe('Accessibility', () => {
  it('has no accessibility violations on homepage', async () => {
    const { container } = render(<HomePage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

### Playwright Accessibility Tests

```typescript
// e2e/accessibility.spec.ts
import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test.describe('Accessibility', () => {
  test('homepage is accessible', async ({ page }) => {
    await page.goto('/');
    
    const accessibilityScanResults = await new AxeBuilder({ page }).analyze();
    expect(accessibilityScanResults.violations).toEqual([]);
  });

  test('keyboard navigation works', async ({ page }) => {
    await page.goto('/');
    
    // Tab through interactive elements
    await page.keyboard.press('Tab');
    await expect(page.getByRole('link', { name: 'Getting Started' })).toBeFocused();
    
    await page.keyboard.press('Tab');
    await expect(page.getByRole('link', { name: 'Testing' })).toBeFocused();
  });
});
```

## Performance Testing

### Lighthouse CI

Create `.lighthouserc.js`:

```javascript
module.exports = {
  ci: {
    collect: {
      url: ['http://localhost:3000/', 'http://localhost:3000/getting-started'],
      numberOfRuns: 3,
    },
    assert: {
      assertions: {
        'categories:performance': ['warn', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.95 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }],
      },
    },
    upload: {
      target: 'temporary-public-storage',
    },
  },
};
```

### Load Testing

```javascript
// scripts/load-test.js
import { check, sleep } from 'k6';
import http from 'k6/http';

export const options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up
    { duration: '5m', target: 100 }, // Stay at 100 users
    { duration: '2m', target: 200 }, // Ramp up to 200 users
    { duration: '5m', target: 200 }, // Stay at 200 users
    { duration: '2m', target: 0 },   // Ramp down
  ],
};

export default function () {
  const response = http.get('http://localhost:3000/');
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

## Testing Best Practices

### 1. Test Organization

```
__tests__/
├── components/          # Component tests
├── hooks/              # Custom hook tests
├── lib/                # Utility function tests
├── pages/              # Page component tests
└── __mocks__/          # Mock implementations

e2e/
├── fixtures/           # Test data
├── page-objects/       # Page object models
└── specs/             # Test specifications
```

### 2. Writing Maintainable Tests

- **Use descriptive test names**: `should display error message when API fails`
- **Follow AAA pattern**: Arrange, Act, Assert
- **Keep tests independent**: Each test should run in isolation
- **Use page object pattern** for E2E tests
- **Mock external dependencies**: APIs, third-party services

### 3. Test Data Management

```javascript
// __tests__/fixtures/testData.js
export const mockUser = {
  id: '1',
  name: 'John Doe',
  email: 'john@example.com',
};

export const mockDocuments = [
  {
    id: '1',
    title: 'Getting Started',
    slug: 'getting-started',
    content: 'Test content',
  },
];
```

### 4. Continuous Integration

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - run: npm ci
      - run: npm run test
      - run: npm run test:e2e
      - run: npm run lighthouse
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

## Running Tests

### Development Commands

```bash
# Run all unit tests
npm run test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage

# Run E2E tests
npm run test:e2e

# Run E2E tests in headed mode
npm run test:e2e:headed

# Run specific test file
npm run test SearchBox.test.jsx

# Run accessibility tests
npm run test:a11y

# Run performance tests
npm run test:performance
```

### CI/CD Commands

```bash
# Run all tests for CI
npm run test:ci

# Generate test reports
npm run test:report

# Run security audit
npm audit

# Check bundle size
npm run analyze
```

## Conclusion

Testing is essential for maintaining high-quality documentation. By implementing comprehensive testing strategies including unit tests, integration tests, E2E tests, accessibility testing, and performance testing, you ensure that your Knowledge Pack documentation remains reliable and user-friendly.

Remember to:

- **Start with unit tests** for core functionality
- **Add integration tests** for component interactions
- **Use E2E tests** for critical user workflows
- **Include accessibility testing** for inclusive design
- **Monitor performance** regularly
- **Automate testing** in your CI/CD pipeline

For more advanced testing scenarios and troubleshooting, refer to our [advanced testing guide](/advanced-testing) or reach out to the community.
